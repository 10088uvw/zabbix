<?xml version="1.0" encoding="UTF-8"?>
<zabbix_export>
   <version>5.0</version>
   <date>2021-02-07T19:40:49Z</date>
   <groups>
      <group>
         <name>Templates/Modules</name>
      </group>
   </groups>
   <templates>
      <template>
         <template>Template SAN NetApp AFF A700 by HTTP</template>
         <name>Template SAN NetApp AFF A700 by HTTP</name>
         <description>The template to monitor SAN NetApp AFF A700 cluster by Zabbix HTTP agent.&#13;
&#13;
You can discuss this template or leave feedback on our forum https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/&#13;
&#13;
Template tooling version used: 0.38</description>
         <groups>
            <group>
               <name>Templates/Modules</name>
            </group>
         </groups>
         <applications>
            <application>
               <name>General</name>
            </application>
            <application>
               <name>Zabbix raw items</name>
            </application>
         </applications>
         <items>
            <item>
               <name>Get Chassis metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.chassis.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/cluster/chassis?fields=id,state</url>
            </item>
            <item>
               <name>Get cluster metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.cluster.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/cluster</url>
            </item>
            <item>
               <name>Cluster location</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.location</key>
               <delay>0</delay>
               <history>7d</history>
               <trends>0</trends>
               <value_type>CHAR</value_type>
               <description>The location of the cluster.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.location</params>
                  </step>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>6h</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster name</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.name</key>
               <delay>0</delay>
               <history>7d</history>
               <trends>0</trends>
               <value_type>CHAR</value_type>
               <description>The name of the cluster.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.name</params>
                  </step>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>6h</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster iops other</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.iops.other.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <description>The number of I/O operations observed at the storage object. Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.iops_raw.other</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster iops read</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.iops.read.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <description>The number of I/O operations observed at the storage object. Performance metric for read I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.iops_raw.read</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster iops total</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.iops.total.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <description>The number of I/O operations observed at the storage object. Performance metric aggregated over all types of I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.iops_raw.total</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster iops write</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.iops.write.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <description>The number of I/O operations observed at the storage object. Peformance metric for write I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.iops_raw.write</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster latency other</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.latency.other</key>
               <delay>0</delay>
               <history>7d</history>
               <value_type>FLOAT</value_type>
               <units>s</units>
               <description>The latency in seconds observed at the storage object. Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.latency_raw.other</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>0.000001</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster latency read</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.latency.read</key>
               <delay>0</delay>
               <history>7d</history>
               <value_type>FLOAT</value_type>
               <units>s</units>
               <description>The latency in seconds observed at the storage object. Performance metric for read I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.latency_raw.read</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>0.000001</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster latency total</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.latency.total</key>
               <delay>0</delay>
               <history>7d</history>
               <units>s</units>
               <description>The latency in seconds observed at the storage object. Performance metric aggregated over all types of I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.latency_raw.total</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>0.000001</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster latency write</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.latency.write</key>
               <delay>0</delay>
               <history>7d</history>
               <value_type>FLOAT</value_type>
               <units>s</units>
               <description>The latency in seconds observed at the storage object. Peformance metric for write I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.latency_raw.write</params>
                  </step>
                  <step>
                     <type>MULTIPLIER</type>
                     <params>0.000001</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster throughput other</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.throughput.other.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <units>Bps</units>
               <description>Throughput bytes observed at the storage object. Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.throughput_raw.other</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster throughput read</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.throughput.read.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <units>Bps</units>
               <description>Throughput bytes observed at the storage object. Performance metric for read I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.throughput_raw.read</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster throughput total</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.throughput.total.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <units>Bps</units>
               <description>Throughput bytes observed at the storage object. Performance metric aggregated over all types of I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.throughput_raw.total</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster throughput write</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.statistics.throughput.write.rate</key>
               <delay>0</delay>
               <history>7d</history>
               <units>Bps</units>
               <description>Throughput bytes observed at the storage object. Peformance metric for write I/O operations.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.throughput_raw.write</params>
                  </step>
                  <step>
                     <type>CHANGE_PER_SECOND</type>
                     <params/>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
            </item>
            <item>
               <name>Cluster status</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.status</key>
               <delay>0</delay>
               <history>7d</history>
               <trends>0</trends>
               <value_type>CHAR</value_type>
               <description>The status of the cluster: ok, error, partial_no_data, partial_no_response, partial_other_error, negative_delta, backfilled_data, inconsistent_delta_time, inconsistent_old_data.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.statistics.status</params>
                  </step>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>6h</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>({last()}&lt;&gt;"ok")</expression>
                     <name>Cluster has status different from normal</name>
                     <priority>AVERAGE</priority>
                     <description>Any errors associated with the sample. For example, if the aggregation of data over multiple nodes fails then any of the partial errors might be returned, “ok” on success, or “error” on any internal uncategorized failure. Whenever a sample collection is missed but done at a later time, it is back filled to the previous 15 second timestamp and tagged with "backfilled_data". “Inconsistent_ delta_time” is encountered when the time between two collections is not the same for all nodes. Therefore, the aggregated value might be over or under inflated. “Negative_delta” is returned when an expected monotonically increasing value has decreased in value. “Inconsistent_old_data” is returned when one or more nodes does not have the latest data.</description>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>Cluster software version</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.cluster.version</key>
               <delay>0</delay>
               <history>7d</history>
               <trends>0</trends>
               <value_type>CHAR</value_type>
               <description>This returns the cluster version information. When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.</description>
               <applications>
                  <application>
                     <name>General</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JSONPATH</type>
                     <params>$.version.full</params>
                  </step>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>6h</params>
                  </step>
               </preprocessing>
               <master_item>
                  <key>netapp.aff.cluster.get</key>
               </master_item>
               <triggers>
                  <trigger>
                     <expression>{diff()}=1 and {strlen()}&gt;0</expression>
                     <name>Version has changed (new version: {ITEM.VALUE})</name>
                     <priority>INFO</priority>
                     <description>__RESOURCE__ version has changed. Ack to close.</description>
                     <manual_close>YES</manual_close>
                  </trigger>
               </triggers>
            </item>
            <item>
               <name>Get disks metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.disks.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/storage/disks?fields=state,node.name</url>
            </item>
            <item>
               <name>Get FRUs metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.frus.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function(chassis) {
    chassis.frus.forEach(function(frus) {
        frus.chassisId = chassis.id;
        result.push(frus);
    })
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/cluster/chassis?fields=id,frus.id,frus.state</url>
            </item>
            <item>
               <name>Get LUNs metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.luns.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/storage/luns?fields=name,svm.name,space.size,space.used,status.state,status.container_state</url>
            </item>
            <item>
               <name>Get nodes metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.nodes.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/cluster/nodes?fields=*</url>
            </item>
            <item>
               <name>Get ehternet ports metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.ports.eth.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/network/ethernet/ports?fields=name,type,node.name,broadcast_domain.name,enabled,state,mtu,speed</url>
            </item>
            <item>
               <name>Get FC ports metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.ports.fc.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/network/fc/ports?fields=name,node.name,description,enabled,fabric.switch_port,state</url>
            </item>
            <item>
               <name>Get SVMs metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.svms.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/svm/svms?fields=name,state,comment</url>
            </item>
            <item>
               <name>Get volumes metrics</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.volumes.get</key>
               <history>0</history>
               <trends>0</trends>
               <value_type>TEXT</value_type>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <applications>
                  <application>
                     <name>Zabbix raw items</name>
                  </application>
               </applications>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/storage/volumes?fields=name,comment,state,type,svm.name,space.size,space.available,space.used,statistics</url>
            </item>
         </items>
         <discovery_rules>
            <discovery_rule>
               <name>Chassis discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.chassis.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/cluster/chassis?fields=id</url>
               <item_prototypes>
                  <item_prototype>
                     <name>{#ID}: State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.chassis.state[{#ID}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The chassis state: ok, error.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Chassis "{#ID}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.id=='{#ID}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.chassis.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}="error")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="ok")</recovery_expression>
                           <name>{#ID}: Chassis "{#ID}" has something errors</name>
                           <priority>AVERAGE</priority>
                           <description>Something wrong with the chassis.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (chassis) {
    result.push({"{#ID}": chassis.id});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Disks discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.disks.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/storage/disks?fields=name,node.name</url>
               <item_prototypes>
                  <item_prototype>
                     <name>{#DISKNAME}: State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.disk.state[{#NODENAME},{#DISKNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The state of the disk. Possible values: broken, copy, maintenance, partner, pending, present, reconstructing, removed, spare, unfail, zeroing</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}" disks</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#DISKNAME}'&amp;&amp;@.node.name=='{#NODENAME}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.disks.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}&lt;&gt;"present")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="present")</recovery_expression>
                           <name>{#DISKNAME}: Node "{#NODENAME}" Disk "{#DISKNAME}" has state different from "present"</name>
                           <priority>AVERAGE</priority>
                           <description>Something wrong with the disk.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (disk) {
    result.push({"{#DISKNAME}": disk.name, "{#NODENAME}": disk.node.name});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>FRUs discovery</name>
               <type>DEPENDENT</type>
               <key>netapp.aff.frus.discovery</key>
               <delay>0</delay>
               <item_prototypes>
                  <item_prototype>
                     <name>{#FRUID}: State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.chassis.fru.state[{#CHASSISID},{#FRUID}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The FRU state: ok, error.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Chassis "{#CHASSISID}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$[?(@.id=='{#FRUID}'&amp;&amp;@.chassisId=='{#CHASSISID}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.frus.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}="error")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="ok")</recovery_expression>
                           <name>{#FRUID}: Chassis "{#ID}" "{#FRUID}" state is error</name>
                           <priority>AVERAGE</priority>
                           <description>Something wrong with the FRU.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <master_item>
                  <key>netapp.aff.frus.get</key>
               </master_item>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).forEach(function (fru) {
    result.push({"{#CHASSISID}": fru.chassisId, "{#FRUID}": fru.id});
});

return JSON.stringify(result);
</params>
                  </step>
                  <step>
                     <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                     <params>6h</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>LUNs discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.luns.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/storage/luns?fields=name,svm.name,space.size,space.used,status.state,status.container_state</url>
               <item_prototypes>
                  <item_prototype>
                     <name>LUN "{#LUNNAME}": Space size</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.lun.space.size[{#SVMNAME},{#LUNNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>B</units>
                     <description>The total provisioned size of the LUN.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>SVM "{#SVMNAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.svm.name=='{#SVMNAME}'&amp;&amp;@.name=='{#LUNNAME}')].space.size.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.luns.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>LUN "{#LUNNAME}": Space used</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.lun.space.used[{#SVMNAME},{#LUNNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>B</units>
                     <description>The amount of space consumed by the main data stream of the LUN.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>SVM "{#SVMNAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.svm.name=='{#SVMNAME}'&amp;&amp;@.name=='{#LUNNAME}')].space.used.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.luns.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>LUN "{#LUNNAME}": Container state</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.lun.status.container_state[{#SVMNAME},{#LUNNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The state of the volume and aggregate that contain the LUN: online, aggregate_offline, volume_offline. LUNs are only available when their containers are available.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>SVM "{#SVMNAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.svm.name=='{#SVMNAME}'&amp;&amp;@.name=='{#LUNNAME}')].status.container_state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.luns.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}&lt;&gt;"online")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="online")</recovery_expression>
                           <name>LUN "{#LUNNAME}": SVM "{#SVMNAME}" LUN "{#LUNNAME}" has abnormal container state</name>
                           <priority>AVERAGE</priority>
                           <description>LUNs are only available when their containers are available.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>LUN "{#LUNNAME}": State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.lun.status.state[{#SVMNAME},{#LUNNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The state of the LUN. Normal states for a LUN are online and offline. Other states indicate errors. Possible values: foreign_lun_error, nvfail, offline, online, space_error.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>SVM "{#SVMNAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.svm.name=='{#SVMNAME}'&amp;&amp;@.name=='{#LUNNAME}')].status.state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.luns.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}&lt;&gt;"online")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="online")</recovery_expression>
                           <name>LUN "{#LUNNAME}": SVM "{#SVMNAME}" LUN "{#LUNNAME}" has abnormal state</name>
                           <priority>AVERAGE</priority>
                           <description>Normal states for a LUN are online and offline. Other states indicate errors.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (lun) {
    result.push({"{#LUNNAME}": lun.name, "{#SVMNAME}": lun.svm.name});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Nodes discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.nodes.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/cluster/nodes?fields=name</url>
               <item_prototypes>
                  <item_prototype>
                     <name>: {#NODENAME} software version</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.node.version[{#NODENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>This returns the cluster version information. When the cluster has more than one node, the cluster version is equivalent to the lowest of generation, major, and minor versions on all nodes.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#NODENAME}')].version.full.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.nodes.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{diff()}=1 and {strlen()}&gt;0</expression>
                           <name>: Version has changed (new version: {ITEM.VALUE})</name>
                           <priority>INFO</priority>
                           <description>version has changed. Ack to close.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>: {#NODENAME} controller.over_temperature</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.nodes.controller.over_temperature[{#NODENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>Specifies whether the hardware is currently operating outside of its recommended temperature range. The hardware shuts down if the temperature exceeds critical thresholds. Possible values: over, normal</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#NODENAME}')].controller.over_temperature.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.nodes.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({last()}&lt;&gt;"normal")</expression>
                           <name>: Node {#NODENAME} has over temperature</name>
                           <priority>AVERAGE</priority>
                           <description>The hardware shuts down if the temperature exceeds critical thresholds(item's value is "over").</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>: {#NODENAME} location</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.nodes.location[{#NODENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The location of the node.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#NODENAME}')].location.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.nodes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>: {#NODENAME} membership</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.nodes.membership[{#NODENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>Possible values:&#13;
  available - If a node is available, this means it is detected on the internal cluster network and can be added to the cluster. Nodes that have a membership of “available” are not returned when a GET request is called when the cluster exists. A query on the “membership” property for available must be provided to scan for nodes on the cluster network. Nodes that have a membership of “available” are returned automatically before a cluster is created.&#13;
  joining - Joining nodes are in the process of being added to the cluster. The node may be progressing through the steps to become a member or might have failed. The job to add the node or create the cluster provides details on the current progress of the node.&#13;
  member - Nodes that are members have successfully joined the cluster.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#NODENAME}')].membership.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.nodes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>: {#NODENAME} state</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.nodes.state[{#NODENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>State of the node:&#13;
up - Node is up and operational.&#13;
booting - Node is booting up.&#13;
down - Node has stopped or is dumping core.&#13;
taken_over - Node has been taken over by its HA partner and is not yet waiting for giveback.&#13;
waiting_for_giveback - Node has been taken over by its HA partner and is waiting for the HA partner to giveback disks.&#13;
degraded - Node has one or more critical services offline.&#13;
unknown - Node or its HA partner cannot be contacted and there is no information on the node’s state.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#NODENAME}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.nodes.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({last()}&lt;&gt;"up")</expression>
                           <name>: Node {#NODENAME} has state different from normal</name>
                           <priority>AVERAGE</priority>
                           <description>The state of the node is different from up:&#13;
booting - Node is booting up.&#13;
down - Node has stopped or is dumping core.&#13;
taken_over - Node has been taken over by its HA partner and is not yet waiting for giveback.&#13;
waiting_for_giveback - Node has been taken over by its HA partner and is waiting for the HA partner to giveback disks.&#13;
degraded - Node has one or more critical services offline.&#13;
unknown - Node or its HA partner cannot be contacted and there is no information on the node’s state.</description>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>: {#NODENAME} uptime</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.nodes.uptime[{#NODENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>s</units>
                     <description>The total time, in seconds, that the node has been up.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#NODENAME}')].uptime.first()</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.nodes.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>{last()}&lt;10m</expression>
                           <name>: Node {#NODENAME} has been restarted (uptime &lt; 10m)</name>
                           <priority>INFO</priority>
                           <description>Uptime is less than 10 minutes</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (node) {
    result.push({"{#NODENAME}": node.name});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Ethernet ports discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.ports.ether.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/network/ethernet/ports?fields=name,state,node.name</url>
               <item_prototypes>
                  <item_prototype>
                     <name>{#ETHPORTNAME}: State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.port.eth.state[{#NODENAME},{#ETHPORTNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The operational state of the port. Possible values: up, down.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}" Ethernet ports</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#ETHPORTNAME}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.ports.eth.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}="down")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="up")</recovery_expression>
                           <name>{#ETHPORTNAME}: Node {#NODENAME} Ethernet port "{#ETHPORTNAME}" is down</name>
                           <priority>AVERAGE</priority>
                           <description>Something wrong with the ethernet port.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (port) {
    result.push({"{#NODENAME}": port.node.name, "{#ETHPORTNAME}": port.name, "{#ETHPORTSTATE}": port.state});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>FC ports discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.ports.fc.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/network/fc/ports?fields=node.name,name,state</url>
               <item_prototypes>
                  <item_prototype>
                     <name>{#FCPORTNAME}: Description</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.port.fc.description[{#NODENAME},{#FCPORTNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>A description of the FC port.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}" FC ports</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#FCPORTNAME}')].description.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.ports.fc.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#FCPORTNAME}: State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.port.fc.state[{#NODENAME},{#FCPORTNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The operational state of the FC port. Possible values:&#13;
startup - The port is booting up.&#13;
link_not_connected - The port has finished initialization, but a link with the fabric is not established.&#13;
online - The port is initialized and a link with the fabric has been established.&#13;
link_disconnected - The link was present at one point on this port but is currently not established.&#13;
offlined_by_user - The port is administratively disabled.&#13;
offlined_by_system - The port is set to offline by the system. This happens when the port encounters too many errors.&#13;
node_offline - The state information for the port cannot be retrieved. The node is offline or inaccessible.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Node "{#NODENAME}" FC ports</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#FCPORTNAME}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.ports.fc.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}&lt;&gt;"online")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="online")</recovery_expression>
                           <name>{#FCPORTNAME}: Node "{#NODENAME}" FC port "{#FCPORTNAME}" has state different from "online"</name>
                           <priority>AVERAGE</priority>
                           <description>Something wrong with the ethernet port.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (port) {
    result.push({"{#NODENAME}": port.node.name, "{#FCPORTNAME}": port.name, "{#FCPORTSTATE}": port.state});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>SVMs discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.svms.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/svm/svms?fields=name</url>
               <item_prototypes>
                  <item_prototype>
                     <name>{#SVMNAME}: Comment</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.svm.comment[{#SVMNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The comment for the SVM.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>SVM "{#SVMNAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#SVMNAME}')].comment.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.svms.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#SVMNAME}: State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.svm.state[{#SVMNAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>SVM state: starting, running, stopping, stopped, deleting.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>SVM "{#SVMNAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#SVMNAME}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.svms.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}&lt;&gt;"running")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="running")</recovery_expression>
                           <name>{#SVMNAME}: SVM "{#SVMNAME}" has abnormal state</name>
                           <priority>AVERAGE</priority>
                           <description>Something wrong with the SVM.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (svm) {
    result.push({"{#SVMNAME}": svm.name});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
            <discovery_rule>
               <name>Volumes discovery</name>
               <type>HTTP_AGENT</type>
               <key>netapp.aff.volumes.discovery</key>
               <delay>1h</delay>
               <authtype>BASIC</authtype>
               <username>{$USERNAME}</username>
               <password>{$PASSWORD}</password>
               <timeout>{$HTTP.AGENT.TIMEOUT}</timeout>
               <url>{$URL}/api/storage/volumes?fields=name</url>
               <item_prototypes>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Comment</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.comment[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>A comment for the volume.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].comment.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Available size</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.space_available[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>B</units>
                     <description>The available space, in bytes.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].space.available.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Space size</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.space_size[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>B</units>
                     <description>Total provisioned size. The default size is equal to the minimum size of 20MB, in bytes.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].space.size.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Used size</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.space_used[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>B</units>
                     <description>The virtual space used (includes volume reserves) before storage efficiency, in bytes.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].space.used.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: State</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.state[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>Volume state. A volume can only be brought online if it is offline. Taking a volume offline removes its junction path. The ‘mixed’ state applies to FlexGroup volumes only and cannot be specified as a target state. An ‘error’ state implies that the volume is not in a state to serve data.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].state.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                     <trigger_prototypes>
                        <trigger_prototype>
                           <expression>({diff()}=1 and {last()}&lt;&gt;"online")</expression>
                           <recovery_mode>RECOVERY_EXPRESSION</recovery_mode>
                           <recovery_expression>({diff()}=1 and {last()}="online")</recovery_expression>
                           <name>{#VOLUMENAME}: Volume "{#VOLUMENAME}" has abnormal state</name>
                           <priority>AVERAGE</priority>
                           <description>A volume can only be brought online if it is offline. Taking a volume offline removes its junction path. The ‘mixed’ state applies to FlexGroup volumes only and cannot be specified as a target state. An ‘error’ state implies that the volume is not in a state to serve data.</description>
                           <manual_close>YES</manual_close>
                        </trigger_prototype>
                     </trigger_prototypes>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume iops other</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.iops.other.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <description>The number of I/O operations observed at the storage object. Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.iops_raw.other.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume iops read</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.iops.read.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <description>The number of I/O operations observed at the storage object. Performance metric for read I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.iops_raw.read.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume iops total</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.iops.total.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <description>The number of I/O operations observed at the storage object. Performance metric aggregated over all types of I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.iops_raw.total.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume iops write</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.iops.write.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <description>The number of I/O operations observed at the storage object. Peformance metric for write I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.iops_raw.write.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume latency other</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.latency.other[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <value_type>FLOAT</value_type>
                     <units>s</units>
                     <description>The raw latency in microseconds observed at the storage object. Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.latency_raw.other.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>0.000001</params>
                        </step>
                        <step>
                           <type>SIMPLE_CHANGE</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume latency read</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.latency.read[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <value_type>FLOAT</value_type>
                     <units>s</units>
                     <description>The raw latency in microseconds observed at the storage object. Performance metric for read I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.latency_raw.read.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>0.000001</params>
                        </step>
                        <step>
                           <type>SIMPLE_CHANGE</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume latency total</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.latency.total[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <value_type>FLOAT</value_type>
                     <units>s</units>
                     <description>The raw latency in microseconds observed at the storage object. Performance metric aggregated over all types of I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.latency_raw.total.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>0.000001</params>
                        </step>
                        <step>
                           <type>SIMPLE_CHANGE</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume latency write</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.latency.write[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <value_type>FLOAT</value_type>
                     <units>s</units>
                     <description>The raw latency in microseconds observed at the storage object. Peformance metric for write I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.latency_raw.write.first()</params>
                        </step>
                        <step>
                           <type>MULTIPLIER</type>
                           <params>0.000001</params>
                        </step>
                        <step>
                           <type>SIMPLE_CHANGE</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume throughput other</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.throughput.other.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>Bps</units>
                     <description>Throughput bytes observed at the storage object. Performance metric for other I/O operations. Other I/O operations can be metadata operations, such as directory lookups and so on.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.throughput_raw.other.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume throughput read</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.throughput.read.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>Bps</units>
                     <description>Throughput bytes observed at the storage object. Performance metric for read I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.throughput_raw.read.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume throughput total</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.throughput.total.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>Bps</units>
                     <description>Throughput bytes observed at the storage object. Performance metric aggregated over all types of I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.throughput_raw.total.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Volume throughput write</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.statistics.throughput.write.rate[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <units>Bps</units>
                     <description>Throughput bytes observed at the storage object. Peformance metric for write I/O operations.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].statistics.throughput_raw.write.first()</params>
                        </step>
                        <step>
                           <type>CHANGE_PER_SECOND</type>
                           <params/>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: SVM name</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.svm_name[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>The volume belongs this SVM.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].svm.name.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
                  <item_prototype>
                     <name>{#VOLUMENAME}: Type</name>
                     <type>DEPENDENT</type>
                     <key>netapp.aff.volume.type[{#VOLUMENAME}]</key>
                     <delay>0</delay>
                     <history>7d</history>
                     <trends>0</trends>
                     <value_type>CHAR</value_type>
                     <description>Type of the volume.&#13;
rw ‐ read-write volume.&#13;
dp ‐ data-protection volume.&#13;
ls ‐ load-sharing dp volume.</description>
                     <application_prototypes>
                        <application_prototype>
                           <name>Volume "{#VOLUMENAME}"</name>
                        </application_prototype>
                     </application_prototypes>
                     <preprocessing>
                        <step>
                           <type>JSONPATH</type>
                           <params>$.records[?(@.name=='{#VOLUMENAME}')].type.first()</params>
                        </step>
                        <step>
                           <type>DISCARD_UNCHANGED_HEARTBEAT</type>
                           <params>6h</params>
                        </step>
                     </preprocessing>
                     <master_item>
                        <key>netapp.aff.volumes.get</key>
                     </master_item>
                  </item_prototype>
               </item_prototypes>
               <host_prototypes/>
               <preprocessing>
                  <step>
                     <type>JAVASCRIPT</type>
                     <params>var result = [];

JSON.parse(value).records.forEach(function (volume) {
    result.push({"{#VOLUMENAME}": volume.name});
});

return JSON.stringify(result);
</params>
                  </step>
               </preprocessing>
            </discovery_rule>
         </discovery_rules>
         <macros>
            <macro>
               <macro>{$HTTP.AGENT.TIMEOUT}</macro>
               <value>3s</value>
               <description>The HTTP agent timeout to wait for a response from AFF700.</description>
            </macro>
            <macro>
               <macro>{$PASSWORD}</macro>
               <description>AFF700 user password.</description>
            </macro>
            <macro>
               <macro>{$URL}</macro>
               <description>AFF700 cluster URL address.</description>
            </macro>
            <macro>
               <macro>{$USERNAME}</macro>
               <description>AFF700 user name.</description>
            </macro>
         </macros>
      </template>
   </templates>
</zabbix_export>
